// ============================================================================
// SE2 project assembler - extracted from lib/assembler.ts
// ============================================================================
import { promises as fs } from "node:fs";
import path from "node:path";
import os from "node:os";
export async function assembleProject(projectId, generatedCode, deployment) {
    const templatePath = path.join(process.cwd(), "templates", "scaffold-eth-2");
    const projectPath = path.join(os.tmpdir(), `se2-${projectId}`);
    try {
        await fs.rm(projectPath, { recursive: true, force: true });
    }
    catch {
        // Ignore if doesn't exist
    }
    await copyDirectory(templatePath, projectPath);
    // Inject contracts into packages/foundry/src/
    for (const contract of generatedCode.contracts) {
        const contractPath = path.join(projectPath, "packages", "foundry", "src", contract.name);
        await fs.mkdir(path.dirname(contractPath), { recursive: true });
        await fs.writeFile(contractPath, contract.content, "utf-8");
    }
    // Inject tests into packages/foundry/test/
    if (generatedCode.tests && generatedCode.tests.length > 0) {
        for (const test of generatedCode.tests) {
            const testPath = path.join(projectPath, "packages", "foundry", "test", test.name);
            await fs.mkdir(path.dirname(testPath), { recursive: true });
            await fs.writeFile(testPath, test.content, "utf-8");
        }
    }
    // Inject pages
    for (const page of generatedCode.pages) {
        const pagePath = path.join(projectPath, "packages", "nextjs", page.path);
        await fs.mkdir(path.dirname(pagePath), { recursive: true });
        await fs.writeFile(pagePath, page.content, "utf-8");
    }
    // Update deployedContracts.ts if deployment info is provided
    if (deployment) {
        await updateDeployedContracts(projectPath, deployment);
    }
    // Create deploy script
    if (generatedCode.contracts.length > 0) {
        await createDeployScript(projectPath, generatedCode.contracts[0].name);
    }
    return projectPath;
}
export async function updateDeployedContracts(projectPath, deployment) {
    const deployedContractsPath = path.join(projectPath, "packages", "nextjs", "contracts", "deployedContracts.ts");
    await fs.mkdir(path.dirname(deployedContractsPath), { recursive: true });
    const content = `import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

/**
 * This file is autogenerated by the dApp builder.
 * You should not edit it manually.
 */

const deployedContracts = {
  ${deployment.networkId}: {
    ${deployment.contractName}: {
      address: "${deployment.contractAddress}" as const,
      abi: ${JSON.stringify(deployment.abi, null, 2)} as const,
    },
  },
} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;
    await fs.writeFile(deployedContractsPath, content, "utf-8");
}
export async function createDeployScript(projectPath, contractFileName) {
    const contractName = contractFileName.replace(".sol", "");
    const deployScriptPath = path.join(projectPath, "packages", "foundry", "script", "Deploy.s.sol");
    await fs.mkdir(path.dirname(deployScriptPath), { recursive: true });
    const content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/${contractName}.sol";

/**
 * @notice Deploy script for ${contractName}
 * @dev Run with: forge script script/Deploy.s.sol --rpc-url <rpc_url> --broadcast
 */
contract DeployScript is Script {
    function run() external returns (${contractName}) {
        uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PRIVATE_KEY");

        vm.startBroadcast(deployerPrivateKey);

        ${contractName} instance = new ${contractName}();

        vm.stopBroadcast();

        console.log("${contractName} deployed at:", address(instance));

        return instance;
    }
}
`;
    await fs.writeFile(deployScriptPath, content, "utf-8");
}
async function copyDirectory(src, dest) {
    await fs.mkdir(dest, { recursive: true });
    const entries = await fs.readdir(src, { withFileTypes: true });
    for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);
        if (entry.isDirectory()) {
            await copyDirectory(srcPath, destPath);
        }
        else {
            await fs.copyFile(srcPath, destPath);
        }
    }
}
export async function getAllFiles(dirPath, basePath = dirPath) {
    const files = [];
    const entries = await fs.readdir(dirPath, { withFileTypes: true });
    for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name);
        const relativePath = path.relative(basePath, fullPath);
        if (entry.isDirectory()) {
            if (entry.name === "node_modules" || entry.name === ".git")
                continue;
            const subFiles = await getAllFiles(fullPath, basePath);
            files.push(...subFiles);
        }
        else {
            const content = await fs.readFile(fullPath, "utf-8");
            files.push({ relativePath, content });
        }
    }
    return files;
}
export async function cleanupProject(projectPath) {
    try {
        await fs.rm(projectPath, { recursive: true, force: true });
    }
    catch {
        // Ignore errors
    }
}
//# sourceMappingURL=assembler.js.map