import { promises as fs } from "fs";
import path from "path";
import os from "os";

export interface GeneratedCode {
  contracts: { name: string; content: string }[];
  pages: { path: string; content: string }[];
  tests?: { name: string; content: string }[];
}

export interface DeploymentInfo {
  contractAddress: string;
  contractName: string;
  abi: unknown[];
  networkId: number;
}

/**
 * Assembles a complete SE2 project by copying the template and injecting generated code
 */
export async function assembleProject(
  projectId: string,
  generatedCode: GeneratedCode,
  deployment?: DeploymentInfo
): Promise<string> {
  const templatePath = path.join(process.cwd(), "templates", "scaffold-eth-2");
  const projectPath = path.join(os.tmpdir(), `se2-${projectId}`);

  // Clean up if exists
  try {
    await fs.rm(projectPath, { recursive: true, force: true });
  } catch {
    // Ignore if doesn't exist
  }

  // Copy template to temp directory
  await copyDirectory(templatePath, projectPath);

  // Inject generated contracts into packages/foundry/src/
  for (const contract of generatedCode.contracts) {
    const contractPath = path.join(
      projectPath,
      "packages",
      "foundry",
      "src",
      contract.name
    );
    await fs.writeFile(contractPath, contract.content, "utf-8");
  }

  // Inject generated tests into packages/foundry/test/
  if (generatedCode.tests && generatedCode.tests.length > 0) {
    for (const test of generatedCode.tests) {
      const testPath = path.join(
        projectPath,
        "packages",
        "foundry",
        "test",
        test.name
      );
      await fs.writeFile(testPath, test.content, "utf-8");
    }
  }

  // Inject generated pages
  for (const page of generatedCode.pages) {
    const pagePath = path.join(projectPath, "packages", "nextjs", page.path);
    await fs.mkdir(path.dirname(pagePath), { recursive: true });
    await fs.writeFile(pagePath, page.content, "utf-8");
  }

  // Update deployedContracts.ts if deployment info is provided
  if (deployment) {
    await updateDeployedContracts(projectPath, deployment);
  }

  // Create deploy script for the generated contract
  if (generatedCode.contracts.length > 0) {
    await createDeployScript(projectPath, generatedCode.contracts[0].name);
  }

  return projectPath;
}

/**
 * Updates the deployedContracts.ts file with deployment information
 */
async function updateDeployedContracts(
  projectPath: string,
  deployment: DeploymentInfo
): Promise<void> {
  const deployedContractsPath = path.join(
    projectPath,
    "packages",
    "nextjs",
    "contracts",
    "deployedContracts.ts"
  );

  const content = `import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

/**
 * This file is autogenerated by the dApp builder.
 * You should not edit it manually.
 */

const deployedContracts = {
  ${deployment.networkId}: {
    ${deployment.contractName}: {
      address: "${deployment.contractAddress}" as const,
      abi: ${JSON.stringify(deployment.abi, null, 2)} as const,
    },
  },
} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  await fs.writeFile(deployedContractsPath, content, "utf-8");
}

/**
 * Creates a Foundry deploy script for the generated contract
 */
async function createDeployScript(
  projectPath: string,
  contractFileName: string
): Promise<void> {
  const contractName = contractFileName.replace(".sol", "");
  const deployScriptPath = path.join(
    projectPath,
    "packages",
    "foundry",
    "script",
    "Deploy.s.sol"
  );

  const content = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "../src/${contractName}.sol";

/**
 * @notice Deploy script for ${contractName}
 * @dev Run with: forge script script/Deploy.s.sol --rpc-url <rpc_url> --broadcast
 */
contract DeployScript is Script {
    function run() external returns (${contractName}) {
        uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PRIVATE_KEY");
        
        vm.startBroadcast(deployerPrivateKey);
        
        ${contractName} instance = new ${contractName}();
        
        vm.stopBroadcast();
        
        console.log("${contractName} deployed at:", address(instance));
        
        return instance;
    }
}
`;

  await fs.writeFile(deployScriptPath, content, "utf-8");
}

/**
 * Recursively copies a directory
 */
async function copyDirectory(src: string, dest: string): Promise<void> {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

/**
 * Gets all files in a directory recursively as a flat list
 */
export async function getAllFiles(
  dirPath: string,
  basePath: string = dirPath
): Promise<{ relativePath: string; content: string }[]> {
  const files: { relativePath: string; content: string }[] = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const relativePath = path.relative(basePath, fullPath);

    if (entry.isDirectory()) {
      // Skip node_modules and .git
      if (entry.name === "node_modules" || entry.name === ".git") {
        continue;
      }
      const subFiles = await getAllFiles(fullPath, basePath);
      files.push(...subFiles);
    } else {
      const content = await fs.readFile(fullPath, "utf-8");
      files.push({ relativePath, content });
    }
  }

  return files;
}

/**
 * Cleans up a temporary project directory
 */
export async function cleanupProject(projectPath: string): Promise<void> {
  try {
    await fs.rm(projectPath, { recursive: true, force: true });
  } catch {
    // Ignore errors
  }
}
