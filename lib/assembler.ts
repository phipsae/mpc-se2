import { promises as fs } from "fs";
import path from "path";
import os from "os";

export interface GeneratedCode {
  contracts: { name: string; content: string }[];
  pages: { path: string; content: string }[];
}

export interface DeploymentInfo {
  contractAddress: string;
  contractName: string;
  abi: unknown[];
  networkId: number;
}

/**
 * Assembles a complete SE2 project by copying the template and injecting generated code
 */
export async function assembleProject(
  projectId: string,
  generatedCode: GeneratedCode,
  deployment?: DeploymentInfo
): Promise<string> {
  const templatePath = path.join(process.cwd(), "templates", "scaffold-eth-2");
  const projectPath = path.join(os.tmpdir(), `se2-${projectId}`);

  // Clean up if exists
  try {
    await fs.rm(projectPath, { recursive: true, force: true });
  } catch {
    // Ignore if doesn't exist
  }

  // Copy template to temp directory
  await copyDirectory(templatePath, projectPath);

  // Inject generated contracts
  for (const contract of generatedCode.contracts) {
    const contractPath = path.join(
      projectPath,
      "packages",
      "hardhat",
      "contracts",
      contract.name
    );
    await fs.writeFile(contractPath, contract.content, "utf-8");
  }

  // Inject generated pages
  for (const page of generatedCode.pages) {
    const pagePath = path.join(projectPath, "packages", "nextjs", page.path);
    await fs.mkdir(path.dirname(pagePath), { recursive: true });
    await fs.writeFile(pagePath, page.content, "utf-8");
  }

  // Update deployedContracts.ts if deployment info is provided
  if (deployment) {
    await updateDeployedContracts(projectPath, deployment);
  }

  // Create deploy script for the generated contract
  if (generatedCode.contracts.length > 0) {
    await createDeployScript(projectPath, generatedCode.contracts[0].name);
  }

  return projectPath;
}

/**
 * Updates the deployedContracts.ts file with deployment information
 */
async function updateDeployedContracts(
  projectPath: string,
  deployment: DeploymentInfo
): Promise<void> {
  const deployedContractsPath = path.join(
    projectPath,
    "packages",
    "nextjs",
    "contracts",
    "deployedContracts.ts"
  );

  const content = `import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";

/**
 * This file is autogenerated by the dApp builder.
 * You should not edit it manually.
 */

const deployedContracts = {
  ${deployment.networkId}: {
    ${deployment.contractName}: {
      address: "${deployment.contractAddress}" as const,
      abi: ${JSON.stringify(deployment.abi, null, 2)} as const,
    },
  },
} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`;

  await fs.writeFile(deployedContractsPath, content, "utf-8");
}

/**
 * Creates a deploy script for the generated contract
 */
async function createDeployScript(
  projectPath: string,
  contractFileName: string
): Promise<void> {
  const contractName = contractFileName.replace(".sol", "");
  const deployScriptPath = path.join(
    projectPath,
    "packages",
    "hardhat",
    "deploy",
    "00_deploy_contract.ts"
  );

  const content = `import { HardhatRuntimeEnvironment } from "hardhat/types";
import { DeployFunction } from "hardhat-deploy/types";

const deployContract: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const { deployer } = await hre.getNamedAccounts();
  const { deploy } = hre.deployments;

  await deploy("${contractName}", {
    from: deployer,
    args: [], // Add constructor arguments if needed
    log: true,
    autoMine: true,
  });
};

export default deployContract;

deployContract.tags = ["${contractName}"];
`;

  await fs.writeFile(deployScriptPath, content, "utf-8");
}

/**
 * Recursively copies a directory
 */
async function copyDirectory(src: string, dest: string): Promise<void> {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

/**
 * Gets all files in a directory recursively as a flat list
 */
export async function getAllFiles(
  dirPath: string,
  basePath: string = dirPath
): Promise<{ relativePath: string; content: string }[]> {
  const files: { relativePath: string; content: string }[] = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const relativePath = path.relative(basePath, fullPath);

    if (entry.isDirectory()) {
      // Skip node_modules and .git
      if (entry.name === "node_modules" || entry.name === ".git") {
        continue;
      }
      const subFiles = await getAllFiles(fullPath, basePath);
      files.push(...subFiles);
    } else {
      const content = await fs.readFile(fullPath, "utf-8");
      files.push({ relativePath, content });
    }
  }

  return files;
}

/**
 * Cleans up a temporary project directory
 */
export async function cleanupProject(projectPath: string): Promise<void> {
  try {
    await fs.rm(projectPath, { recursive: true, force: true });
  } catch {
    // Ignore errors
  }
}
